#[macro_use]
extern crate rocket;

use rocket::{http::Status, routes, serde::json::Json, Build, Rocket, State};
use rocket_db_pools::{Connection, Database};
use serde::{Deserialize, Serialize};
use toql::prelude::{fields, paths, query, Cache, Toql, ToqlApi};
use toql_mysql_async::MySqlAsync as Toql;
use toql_rocket::prelude::{Counted, ToqlQuery};
use error::Result;


mod error;
mod mysql_async_pool;
use mysql_async_pool::MySqlAsyncPool;

// Here comes our Todo item
// Notice the `Toql` derive ------------v
#[derive(Debug, Serialize, Deserialize, Toql)]
#[toql(auto_key)]
pub struct Todo {
    #[serde(default)]   //<-- On insert `id` is undefined -> set to 0
    #[toql(key)]        // <-- Required and must come first
    pub id: u64,

    #[serde(skip_serializing_if = "Option::is_none")] //<-- Dont's serialize, if Toql query does not select it
    pub title: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none", default)] //<- On insert / update `completed` is not required: default -> None
    pub completed: Option<bool>,
}

//
// Here come the CRUD functions
//
#[delete("/<id>")]
pub async fn delete<'a>(
    id: u64,
    mut conn: Connection<TodoDb>,
    cache: &State<Cache>,
) -> Result<Status> {
    let mut toql = Toql::from(&mut *conn, &*cache);

    // Delete an item
    // TodoKey is generated by the Toql derive
    toql.delete_one(TodoKey::from(id)).await?;

    Ok(Status::NoContent)
}

#[put("/<id>", data = "<todo>")]
pub async fn update(
    id: u64,
    mut todo: Json<Todo>,
    cache: &State<Cache>,
    mut conn: Connection<TodoDb>,
) -> Result<Json<Todo>> {
    let mut toql = Toql::from(&mut *conn, &*cache);

    todo.id = id;

    // Update all fields from a single entity that have a value
    // fields!(top) means: Check all fields for updates
    toql.update_one(&mut *todo, fields!(top)).await?;

    // Load all fields from updated item
    let q = query!(Todo, "*, id eq ?", id);
    let u = toql.load_one(q).await?;
    Ok(Json(u))
}

#[post("/", data = "<todo>")]
pub async fn create<'a>(
    mut todo: Json<Todo>,
    cache: &State<Cache>,
    mut conn: Connection<TodoDb>,
) -> Result<Json<Todo>> {
    let mut toql = Toql::from(&mut *conn, &*cache);
    
    // Insert one item
    // paths!(top) => Ignore all nested joins/merges, not important here
    // This will set the `id` to the generated value
    toql.insert_one(&mut *todo, paths!(top)).await?;

    // Load all fields from the created item
    let q = query!(Todo, "*, id eq ?", &todo.id);
    let u = toql.load_one(q).await?;
    Ok(Json(u))
}

#[get("/<id>")]
pub async fn get(
    id: u64,
    cache: &State<Cache>,
    mut conn: Connection<TodoDb>,
) -> Result<Json<Todo>> {
    let mut toql = Toql::from(&mut *conn, &*cache);

    // Load all fields from this item
    let q = query!(Todo, "*, id eq ?", id);
    let u = toql.load_one(q).await?;
    Ok(Json(u))
}

#[get("/?<toql_query..>")]
pub async fn query(
    cache: &State<Cache>,
    mut conn: Connection<TodoDb>,
    toql_query: ToqlQuery, // <!-- Fetch Toql query and page from URL query parameters
) -> Result<Counted<Json<Vec<Todo>>>> 
{

    let mut toql = Toql::from(&mut *conn, &*cache);

    // Parse query
    let (query, page) = toql_query.parse::<Todo>()?;

    // Run query
    let r = toql.load_page(query, page).await?;

    Ok(Counted(Json(r.0), r.1))
}

// The database connection
#[derive(Database)]
#[database("todo_rotomy")]
pub struct TodoDb(MySqlAsyncPool);

// Main to startup the server
//fn main() {
#[launch]
pub async fn rocket() -> Rocket<Build> {
    println!("\n");
    println!("Full CRUD example with Rocket, Toql and MySQL");
    println!("=============================================\n");
    println!("This example assumes that you have a MySQL server");
    println!("running with a database `todo_rotomy`");
    println!("Run the following SQL to create the table `Todo`");
    println!("CREATE TABLE `Todo` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(200) NOT NULL, `completed` tinyint(1) DEFAULT 0, PRIMARY KEY (`id`))");
    println!();
    println!("Start the server with:");
    println!("ROCKET_DATABASES='{{todo_rotomy={{url=mysql://USER:PASS@localhost:3306/todo_rotomy}}}}' cargo run");
    println!();
    println!("Create a todo with `curl localhost:8000/todo -X POST -d '{{\"title\":\"Water plants\"}}'`");
    println!("Update a todo with `curl localhost:8000/todo/ID -X PUT -d '{{\"completed\":\"true\"}}'`");
    println!("Get a single todo with `curl localhost:8000/todo/ID`");
    println!("Get all todos with `curl localhost:8000/todo`");
    println!("Get only completed todos in descending order `curl localhost:8000/todo?query=-id,completed+eq+1`");
    println!("Delete a todo with `curl -X DELETE localhost:8000/todo/ID`");
    println!("\n");

    // Cache keeps Toql mapping information
    let cache = Cache::new();

    // Use tracing to see what Toql is doing
    tracing_subscriber::fmt().try_init().unwrap_or(());

    rocket::build()
        .manage(cache)
        .attach(TodoDb::init())
        .mount("/todo", routes![get, query, create, update, delete])
}
